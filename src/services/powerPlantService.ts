import type { PowerPlantType, InstalledPowerPlant, PowerPlantStats } from '../types/powerPlant';
import type { Hull, ShipClass } from '../types/hull';
import powerPlantData from '../data/powerPlants.json';

/**
 * Get all power plant types
 */
export function getAllPowerPlantTypes(): PowerPlantType[] {
  return powerPlantData.powerPlants as PowerPlantType[];
}

/**
 * Get power plant types available for a specific ship class
 */
export function getPowerPlantTypesForShipClass(shipClass: ShipClass): PowerPlantType[] {
  const classOrder: ShipClass[] = ['small-craft', 'light', 'medium', 'heavy', 'super-heavy'];
  const classIndex = classOrder.indexOf(shipClass);
  
  return getAllPowerPlantTypes().filter((plant) => {
    const minIndex = classOrder.indexOf(plant.minShipClass);
    return classIndex >= minIndex;
  });
}

/**
 * Get a power plant type by ID
 */
export function getPowerPlantTypeById(id: string): PowerPlantType | undefined {
  return getAllPowerPlantTypes().find((plant) => plant.id === id);
}

/**
 * Calculate power generated by a power plant installation
 */
export function calculatePowerGenerated(plant: PowerPlantType, hullPoints: number): number {
  return Math.round(plant.powerPerHullPoint * hullPoints);
}

/**
 * Calculate cost for a power plant installation
 */
export function calculatePowerPlantCost(plant: PowerPlantType, hullPoints: number): number {
  return plant.baseCost + (plant.costPerHullPoint * hullPoints);
}

/**
 * Calculate fuel cost
 */
export function calculateFuelCost(plant: PowerPlantType, fuelHullPoints: number): number {
  if (!plant.requiresFuel || fuelHullPoints === 0) return 0;
  return plant.fuelCostPerHullPoint * fuelHullPoints;
}

/**
 * Calculate endurance in days for a power plant with fuel
 */
export function calculateEnduranceDays(
  plant: PowerPlantType, 
  powerPlantHullPoints: number, 
  fuelHullPoints: number
): number | null {
  if (!plant.requiresFuel || fuelHullPoints === 0) return null;
  
  // Fuel efficiency is power-days per hull point of fuel for a 1-hull-point plant
  // For larger plants, divide by plant size
  const powerDaysPerFuelHP = plant.fuelEfficiency / powerPlantHullPoints;
  return Math.floor(powerDaysPerFuelHP * fuelHullPoints);
}

/**
 * Calculate total stats for an installed power plant
 */
export function calculatePowerPlantStats(installation: InstalledPowerPlant): PowerPlantStats {
  const { type, hullPoints, fuelHullPoints } = installation;
  
  return {
    powerGenerated: calculatePowerGenerated(type, hullPoints),
    totalHullPoints: hullPoints + fuelHullPoints,
    totalCost: calculatePowerPlantCost(type, hullPoints) + calculateFuelCost(type, fuelHullPoints),
    enduranceDays: calculateEnduranceDays(type, hullPoints, fuelHullPoints),
  };
}

/**
 * Calculate total stats for all installed power plants
 */
export function calculateTotalPowerPlantStats(installations: InstalledPowerPlant[]): {
  totalPowerGenerated: number;
  totalHullPoints: number;
  totalCost: number;
  minEnduranceDays: number | null;
} {
  let totalPowerGenerated = 0;
  let totalHullPoints = 0;
  let totalCost = 0;
  let minEnduranceDays: number | null = null;
  
  for (const installation of installations) {
    const stats = calculatePowerPlantStats(installation);
    totalPowerGenerated += stats.powerGenerated;
    totalHullPoints += stats.totalHullPoints;
    totalCost += stats.totalCost;
    
    // Track minimum endurance (fuel-limited plants)
    if (stats.enduranceDays !== null) {
      if (minEnduranceDays === null || stats.enduranceDays < minEnduranceDays) {
        minEnduranceDays = stats.enduranceDays;
      }
    }
  }
  
  return {
    totalPowerGenerated,
    totalHullPoints,
    totalCost,
    minEnduranceDays,
  };
}

/**
 * Validate a power plant installation
 */
export function validatePowerPlantInstallation(
  plant: PowerPlantType,
  hullPoints: number,
  fuelHullPoints: number,
  hull: Hull,
  _existingInstallations: InstalledPowerPlant[],
  usedHullPoints: number
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check minimum size
  if (hullPoints < plant.minSize) {
    errors.push(`${plant.name} requires a minimum of ${plant.minSize} hull points.`);
  }
  
  // Check maximum size
  if (plant.maxSize > 0 && hullPoints > plant.maxSize) {
    errors.push(`${plant.name} has a maximum size of ${plant.maxSize} hull points.`);
  }
  
  // Check ship class
  const classOrder: ShipClass[] = ['small-craft', 'light', 'medium', 'heavy', 'super-heavy'];
  const shipClassIndex = classOrder.indexOf(hull.shipClass);
  const minClassIndex = classOrder.indexOf(plant.minShipClass);
  if (shipClassIndex < minClassIndex) {
    errors.push(`${plant.name} cannot be installed on ${hull.shipClass} ships.`);
  }
  
  // Check available hull points
  const totalHullPointsNeeded = hullPoints + fuelHullPoints;
  const availableHullPoints = hull.hullPoints + hull.bonusHullPoints - usedHullPoints;
  if (totalHullPointsNeeded > availableHullPoints) {
    errors.push(`Not enough hull points available. Need ${totalHullPointsNeeded}, have ${availableHullPoints}.`);
  }
  
  // Check fuel requirement
  if (plant.requiresFuel && fuelHullPoints === 0) {
    errors.push(`${plant.name} requires fuel. Please allocate fuel hull points.`);
  }
  
  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Generate a unique installation ID
 */
export function generateInstallationId(): string {
  return `pp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Format cost for display
 */
export function formatPowerPlantCost(cost: number): string {
  if (cost >= 1_000_000_000) {
    return `$${(cost / 1_000_000_000).toFixed(1)}B`;
  } else if (cost >= 1_000_000) {
    return `$${(cost / 1_000_000).toFixed(1)}M`;
  } else if (cost >= 1_000) {
    return `$${(cost / 1_000).toFixed(0)}K`;
  }
  return `$${cost}`;
}

/**
 * Get tech track display name
 */
export function getTechTrackName(track: string): string {
  const names: Record<string, string> = {
    '-': 'None',
    'G': 'Gravity Manipulation',
    'D': 'Dark Matter Tech',
    'A': 'Antimatter Tech',
    'M': 'Matter Coding',
    'F': 'Fusion Tech',
    'Q': 'Quantum Manipulation',
    'T': 'Matter Transmission',
    'S': 'Super-Materials',
    'P': 'Psi-tech',
    'X': 'Energy Transformation',
    'C': 'Computer Tech',
  };
  return names[track] || track;
}
